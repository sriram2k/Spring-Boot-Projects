package com.example.demo.repo;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

import com.example.demo.controller.RoleController;
import com.example.demo.model.CommentDesModel;
import com.example.demo.model.CommentModel;
import com.example.demo.model.DefectDashboard;
import com.example.demo.model.DefectHisModel;
import com.example.demo.model.DefectModel;
import com.example.demo.model.History;
import com.example.demo.model.Testcase;
import com.mongodb.client.result.DeleteResult;

@Component
public class DefectRepo {
	
	@Autowired
	private MongoTemplate mongoTemplate;
	
	@Autowired
	public DefectHisRepo hrepo;
	
	@Autowired
	CommentRepo crepo;
	
	@Autowired
	SequenceGenerator sequenceGenerator;
	
	@Autowired
	FieldValidation validField;
	
	Logger logger = LoggerFactory.getLogger(RoleController.class);
	

	// Creating defect which in turns creates appropriate defect's history and defect's comment
	public HashMap<String, Object> addDefects(DefectModel defect, String user) {
		HashMap<String, Object> map = new HashMap<String, Object>();
		
		// Field Validation is done for the Request Body parameters
		if(validField.isValidTestcaseId(defect.getTestCaseId()) && 
				validField.isValidString(defect.getExpectedResults()) && validField.isValidString(defect.getActualResults()) && 
				validField.isValidEmployee(defect.getAssignedTo()) && validField.isValidBugStatus(defect.getBugStatus()) && 
				validField.isValidSeverity(defect.getSeverity()) && validField.isValidDefectType(defect.getDefectType()) ) {
			
			// Below set of fields cannot be given by user. They are automatically setted
			if(defect.getDefectId()!=null)
				logger.warn("Defect Id is autogenerated");
			if(defect.getCreatedBy()!=null)
				logger.warn("Defect creation date is automatically updated");
			if(defect.getDefectStatus()!=null)
				logger.warn("Defect Status is automatically setted to active during creation");
			if(defect.getProjectId()!=null)
				logger.warn("Project Id is generated from the testcase id field");
			if(defect.getCreatedBy()!=null)
				logger.warn("Defect Creation user is generated from JWT token");
			if(defect.getUpdatedBy()!=null)
				logger.warn("Initially defect is updated by user who creates it. Initially generated from JWT token");
			if(defect.getLastUpdatedDate()!=null)
				logger.warn("Last Updated Date is automatically updated");
			
			// Sequence Generator is used for storing defects
			long id=sequenceGenerator.generateDefectSequence();
			defect.setDefectId("D" + id);
			defect.setCreatedDate(new Date());
			defect.setLastUpdatedDate(new Date());
			defect.setUpdatedBy(user);
			// Generating project Id from the value entered in testcaseId field. This uses project table
			Query query = new Query();
			Criteria c = new Criteria();
			c.and("testcaseId").is(defect.getTestCaseId());
			query.addCriteria(c);
			Testcase tc =mongoTemplate.findOne(query, Testcase.class);
			// Project Id is setted 
			defect.setProjectId(tc.getProjectId());
			defect.setCreatedBy(user);
			// Initially all defects that are added are active
			defect.setDefectStatus("active");
			logger.info("Defect has been successfully saved");
			DefectModel m = mongoTemplate.save(defect);
			
			// creation of appropriate defect's history
			hrepo.addDefectHistory(defect);
			logger.info("Defect History has been created for the required Defect");
			
			// creation of appropriate defect's comment
			crepo.addComment(defect);
			logger.info("Comment has been created for the required Defect");
			map.put("Defect : ", m);
			return map;
		}
		else {
			// This is entirely for user to know the invalid field value
			if(validField.isValidTestcaseId(defect.getTestCaseId()) == false) {
				map.put("Invalid TestcaseId : ", "Please Enter valid TestcaseId");
				logger.error("TestCase Id is invalid");
			}
			if(validField.isValidString(defect.getExpectedResults()) == false) { 
				map.put("Invalid Expected Results : ", "Please Enter valid Expected Results");
				logger.error("String in Expected Results is invalid");
			}
			if(validField.isValidString(defect.getActualResults()) == false) {
				map.put("Invalid Actual Results : ", "Please Enter valid Actual Results");
				logger.error("String in Actual Results is invalid");
			}
			if(validField.isValidEmployee(defect.getAssignedTo()) == false) {
				map.put("Invalid User Id : ", "Please Enter valid User Id");
				logger.error("User Id entered in Assigned To field is invalid");
			}
			if(validField.isValidBugStatus(defect.getBugStatus()) == false) {
				map.put("Invalid Bug Status : ", "Please Enter valid Bug Status like new, open, fixed, retest, verified");
				logger.error("Invalid Bug Status" );
			}
			if(validField.isValidSeverity(defect.getSeverity()) == false) { 
				map.put("Invalid Severity : ", "Please Enter valid Severity like 1, 2, 3");
				logger.error("Invalid Severity integer");
			}
			if(validField.isValidDefectType(defect.getDefectType()) == false) { 
				map.put("Invalid Defect Type : ", "Please Enter valid Defect Type like Requirement, Not a Requirement, WAD, Invalid Defect");
				logger.error("Invalid Defect Type");
			}
			if(validField.isValidAttachment(defect.getAttachmentLinks()) == false) {
				map.put("Invalid Attachment List : ", "Please Enter valid Attachment List. List should contain atleast one value");
				logger.error("Attachment Link is invalid");
			}
		}
		return map;
     }
	
	// Display all defects
	public List<DefectModel> findAllValidDefects() {
		List<DefectModel> defect = null;
	        Query query = new Query();
			Criteria criteria = new Criteria();
			// Getting all active defects
			criteria.and("defectStatus").is("active");
			query.addCriteria(criteria);
			defect=mongoTemplate.find(query, DefectModel.class);
			if(defect.isEmpty())
				logger.info("No Defect found)");
			else
				logger.info("Displays all Active Defects");
		return defect;
	}

	// Display defects by defect ID
	public DefectModel findByDefectId(String defectId) {
		DefectModel defect = new DefectModel();
			Query query=new Query();
			Criteria c = new Criteria();
			// If user enters d1 instead of D1, this takes care of it
			defectId = Character.toUpperCase(defectId.charAt(0)) + defectId.substring(1);
			
			c.and("defectId").is(defectId);
	        query.addCriteria(c);
			defect=mongoTemplate.findOne(query,DefectModel.class);
			if(defect == null)
				logger.error("No such defect found");
			else
				logger.info("Displaying particular Defect Details");
		return defect;
	}

	// Displaying list of defects of particular project ID
	public List<DefectModel> findByProjectId(String projectId) {
		Query query = new Query();
		projectId = Character.toUpperCase(projectId.charAt(0)) + projectId.substring(1);
		query.addCriteria(Criteria.where("projectId").is(projectId));
		List<DefectModel> project = mongoTemplate.find(query, DefectModel.class);
		if(project.isEmpty())
			logger.info("No Defect matches with required project id)");
		else
			logger.info("Displays all Defects of particular project id");
        return project;
	}
	
	
	

	// Update defect record partially
	public HashMap<String, Object> updateDefects(String defectId, DefectModel newDefect, String user) {
		Query query = new Query();
		int flag = 1;
		Criteria criteria = new Criteria();
		defectId = Character.toUpperCase(defectId.charAt(0)) + defectId.substring(1);
		criteria.and("defectId").is(defectId);
		criteria.and("defectStatus").is("active");
		query.addCriteria(criteria);
		// Fetching defect that has to be updated
		DefectModel defect = mongoTemplate.findOne(query, DefectModel.class);
		HashMap<String, Object> map = new HashMap<String, Object>();
		if(defect == null || defect.getDefectStatus().equals("closed")) {
			map.put("Defect : ", "Defect does not exists");
			logger.error("Invalid Defect id or Defect may be closed");
			return map;
		}
		else if(defect.getDefectStatus().equals("active")) {
			flag = 0;
			// These are some fields that cannot be updated
			if(newDefect.getDefectId()!=null)
				logger.error("Defect Id cannot be modified");
			if(newDefect.getCreatedBy()!=null)
				logger.warn("Defect creation date cannot be updated");
			if(newDefect.getProjectId()!=null)
				logger.warn("Project Id is generated from the testcase id field");
			if(newDefect.getCreatedBy()!=null)
				logger.warn("Defect Creation user cannot be updated");
			if(newDefect.getUpdatedBy()!=null)
				logger.warn("Updated By cannot be entered manually");
			if(newDefect.getLastUpdatedDate()!=null)
				logger.warn("Last Updated Date is automatically updated");
			if(newDefect.getDefectStatus()!=null)
				logger.warn("Defect Status cannot be updated. Invalid input or Try deleting defect instead");
			defect.setLastUpdatedDate(new Date());
			defect.setUpdatedBy(user);
			// Updating testcaseId
			if(newDefect.getTestCaseId()!=null) {
				if( validField.isValidTestcaseId(newDefect.getTestCaseId())) {
					// Updating testcase id
					defect.setTestCaseId(newDefect.getTestCaseId());
					Query q = new Query();
					Criteria c = new Criteria();
					c.and("testcaseId").is(newDefect.getTestCaseId());
					query.addCriteria(c);
					Testcase tc =mongoTemplate.findOne(q, Testcase.class);
					// updating project id associated with new testcase id
					defect.setProjectId(tc.getProjectId());
					logger.info("TestCaseId has been updated");
				}
				else {
					flag = 1;
					logger.error("Invalid TestCase Id");
					map.put("Invalid TestCase Id : ", "Please Enter valid Testcase Id");
				}
			}
			// updating expected results field
			if(newDefect.getExpectedResults()!=null) {
				if( validField.isValidString(newDefect.getExpectedResults())) {
					defect.setExpectedResults(newDefect.getExpectedResults());
					logger.info("Expected Results has been updated");
				}
				else {
					flag = 1;
					logger.error("Invalid String found in Expected Results ");
					map.put("Invalid Expected Results : ", "Please Enter valid string in expected results ");
				}
			}
			// updating actual results field	
			if(newDefect.getActualResults()!=null) {
				if( validField.isValidString(newDefect.getActualResults())) {
					defect.setActualResults(newDefect.getActualResults());
					logger.info("Actual Results has been updated");
				}
				else {
					flag = 1;
					logger.error("Invalid String found in Actual Results ");
					map.put("Invalid Actual Results : ", "Please Enter valid string in Actual results ");
				}
			}
			// updating severity field	
			if(newDefect.getSeverity()!=0) {
				if( validField.isValidSeverity(newDefect.getSeverity())) {
					defect.setSeverity(newDefect.getSeverity());
					logger.info("Severity has been updated");
				}
				else {
					flag = 1;
					logger.error("Invalid Severity Integer ");
					map.put("Invalid Severity : ", "Please Enter valid integer in Severity like 1, 2, 3");
				}
			}
			// updating defect type
			if(newDefect.getDefectType()!=null) {
				if( validField.isValidDefectType(newDefect.getDefectType())) {
					defect.setDefectType(newDefect.getDefectType());
					logger.info("Defect Type has been updated");
				}
				else {
					flag = 1;
					logger.error("Invalid Defect Type ");
					map.put("Invalid Defect Type : ", "Please Enter valid Defect Type like Requirement, Not a Requirement, WAD, Invalid Defect");
				}
				
			}
			// updating attachment links
			if(newDefect.getAttachmentLinks()!=null) {
				if( validField.isValidAttachment(newDefect.getAttachmentLinks())) {
					Set<String> attach = defect.getAttachmentLinks();
					attach.addAll(newDefect.getAttachmentLinks());
					defect.setAttachmentLinks(attach);
					logger.info("Attachment Links have been updated");
				}
				else {
					flag = 1;
					map.put("Invalid Attachment List : ", "Please Enter valid Attachment List. List should contain atleast one value");
					logger.error("Attachment Link is invalid");
				}
				
			}
			// updating assigned to field. This will add updation in defect history table also
			if(newDefect.getAssignedTo()!=null) {
				if( validField.isValidEmployee(newDefect.getAssignedTo())) {
					
					defect.setAssignedTo(newDefect.getAssignedTo());
					hrepo.updateDefectHisAssignedTo(defectId, defect, user);
					logger.info("Defect is assigned to other user");
				}
				else {
					flag = 1;
					map.put("Invalid User Id : ", "Please Enter valid User Id");
					logger.error("User Id in Assigned To is invalid");
				}
			}
			
			// updating bug status field. This will add updation in defect history table also
			if(newDefect.getBugStatus()!=null) {
				if( validField.isValidBugStatus(newDefect.getBugStatus())) {
					defect.setBugStatus(newDefect.getBugStatus());
					defect.setUpdatedBy(user);
					hrepo.updateDefectHisBug(defectId, defect, user);
					logger.info("Bug status of specified defect has been updated");
				}
				else {
					flag = 1;
					map.put("Invalid Bug Status : ", "Please Enter valid Bug Status");
					logger.error("Bug Status is invalid");
				}	
			}
			
			if(flag == 0) {
				// if control does not enter any of above else part, then validation is success and so data is saved
				mongoTemplate.save(defect);
				map.put("Updated Defect : " , defect);
			}
		} 
		return map;
	}
	
	
	
	// Remove Defect (changing status to closed ) by defect Id in defect, comment, defect history tables. 
	public String removeDefectByDefectId(String defectId, String user) {
		defectId = Character.toUpperCase(defectId.charAt(0)) + defectId.substring(1);
		// Fetching defect 
		DefectModel m = findByDefectId(defectId);
		if(m!=null) {
			logger.info("Updating date of deletion of specific defect");
			m.setLastUpdatedDate(new Date());
			m.setUpdatedBy(user);
			m.setDefectStatus("closed"); // deletion of defect
			logger.info("One Defect is deleted in Defects Collection");
			DefectHisModel dm = hrepo.findDefectHistoryByDefectId(defectId);
			dm = hrepo.closeDefectHistory(defectId, user);
			logger.info("Defect History associated with the deleted defect is closed");
			dm.setDefectStatus("closed"); // Defect History associated with the deleted defect is closed
			CommentModel cm = crepo.findCommentByDefectId(defectId);
			cm.setDefectStatus("closed"); // Comment associated with the deleted defect is closed
			logger.info("Comment associated with the deleted defect is closed");
			
			// Saving all three documents ( records )
			mongoTemplate.save(m);
			mongoTemplate.save(dm);
			mongoTemplate.save(cm);
			return "Defect Deleted Successfully";
		}
		return "Defect does not exists" ;
	}
	
	// Dashboard Service Real time call to db dip
	public DefectDashboard defectDashboard() {
		List<DefectModel> list =  mongoTemplate.findAll(DefectModel.class);
		DefectDashboard db = new DefectDashboard();
		db.setDate(new Date());
		for(DefectModel m : list) {
			if(m.getDefectStatus().toLowerCase().equals("active")) {
				if(m.getBugStatus().toLowerCase().equals("new"))
					db.setNew(db.getNew()+1);
				else if(m.getBugStatus().toLowerCase().equals("open"))
					db.setOpen(db.getOpen() + 1);
				else if(m.getBugStatus().toLowerCase().equals("retest"))
					db.setRetest(db.getRetest() + 1);
				else if(m.getBugStatus().toLowerCase().equals("fixed"))
					db.setFixed(db.getFixed() + 1);
				else if(m.getBugStatus().toLowerCase().equals("verified"))
					db.setClosed(db.getClosed() + 1);
			}
		}
		return db;
		
	}

}
